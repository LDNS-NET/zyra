# ZiSP MikroTik Onboarding Script
# Generated for router: {{name}}
# Router ID: {{router_id}}

# Configuration variables
:local username "{{username}}"
:local password "{{router_password}}"
:local apiPort "{{api_port}}"
:local radiussecret "{{radius_secret}}"
:local radiusip "{{radius_ip}}"
:local trustedIp "{{trusted_ip}}"

:put "==================== ZiSP MIKROTIK ONBOARDING ===================="

# Check internet connectivity
:if ([/ping 8.8.8.8 count=3] = 0) do={
    :put "Warning: No internet connection"
} else={
    :put "Internet connectivity: OK"
}

# Set router identity
/system identity set name="{{name}}"
:put "Router identity: {{name}}"

# Display router IP addresses
:put "==================== ROUTER IP ADDRESSES ===================="
:do {
    :local ipIds [/ip address find]
    :foreach id in=$ipIds do={
        :local ipAddr [/ip address get $id address]
        :if ([:len $ipAddr] > 0) do={
            :put "  - $ipAddr"
        }
    }
} on-error={
    :put "  - Run: /ip address print to see IPs"
}
:put "=============================================================="

# Remove existing RADIUS server
:do {
    /radius remove [find address=$radiusip]
} on-error={}

# Configure RADIUS (try with hotspot, fallback to ppp only)
:local radiusServices "ppp"
:do {
    /ip hotspot print
    :set radiusServices "ppp,hotspot"
} on-error={}
:do {
    /radius add service=$radiusServices address=$radiusip secret=$radiussecret disabled=no timeout=3000ms accounting-port=1813 authentication-port=1812
    :put "RADIUS server configured"
} on-error={
    :do {
        /radius add service=ppp address=$radiusip secret=$radiussecret disabled=no timeout=3000ms accounting-port=1813 authentication-port=1812
        :put "RADIUS configured (PPPoE only)"
    } on-error={
        :put "Warning: RADIUS configuration failed"
    }
}

# Configure PPP AAA
:do {
    /ppp aaa set use-radius=yes accounting=yes interim-update=1h
} on-error={}

# Create or update API user
:local userExists [/user find name=$username]
:if ([:len $userExists] > 0) do={
    :do {
        /user set [find name=$username] password=$password group=full disabled=no comment="ZiSP API User"
        :put "API user updated"
    } on-error={
        :local fullUsers [/user find group=full]
        :if ([:len $fullUsers] > 1) do={
            /user remove [find name=$username]
            /user add name=$username password=$password group=full disabled=no comment="ZiSP API User"
        } else={
            /user set [find name=$username] password=$password comment="ZiSP API User"
        }
        :put "API user updated"
    }
} else={
    /user add name=$username password=$password group=full disabled=no comment="ZiSP API User"
    :put "API user created"
}

# Configure firewall rules for trusted IP
:do {
    /ip firewall filter remove [find comment="zisp-api"]
} on-error={}
:do {
    :local firstIn [/ip firewall filter find chain=input]
    :local firstOut [/ip firewall filter find chain=output]
    :if ([:len $firstIn] > 0) do={
        /ip firewall filter add chain=input action=accept src-address=$trustedIp comment="zisp-api" place-before=[pick $firstIn 0]
    } else={
        /ip firewall filter add chain=input action=accept src-address=$trustedIp comment="zisp-api"
    }
    :if ([:len $firstOut] > 0) do={
        /ip firewall filter add chain=output action=accept dst-address=$trustedIp comment="zisp-api" place-before=[pick $firstOut 0]
    } else={
        /ip firewall filter add chain=output action=accept dst-address=$trustedIp comment="zisp-api"
    }
    :put "Firewall rules configured"
} on-error={
    :put "Warning: Firewall configuration failed"
}

# Enable API service (allow from any IP for initial setup, can be restricted later)
:do {
    /ip service set api disabled=no port=$apiPort address=0.0.0.0/0
    :put "API service enabled on port $apiPort (accessible from any IP)"
} on-error={
    :put "Warning: API service configuration failed"
    :do {
        # Fallback: try to enable without address restriction
        /ip service set api disabled=no port=$apiPort
        :put "API service enabled on port $apiPort (fallback)"
    } on-error={
        :put "Error: Could not enable API service"
    }
}

# === WireGuard onboarding (automated) ===
# This block will attempt to create a WireGuard interface, generate a keypair,
# optionally request or set a tunnel IP, add the server peer and phone-home with
# the WG public key so the cloud application can register this peer.
# Placeholders available from server: {{wg_server_endpoint}}, {{wg_server_pubkey}}, {{wg_subnet}}, {{wg_port}}, and {{sync_url}}

:put "==================== WIREGUARD ONBOARDING ===================="
:if ([:len "{{wg_server_pubkey}}"] > 0 && [:len "{{wg_server_endpoint}}"] > 0) do={
    :put "WireGuard server info present, attempting automated WireGuard setup..."
    
    # Remove existing wg interface named zisp-wg if present
    :do {
        /interface wireguard remove [find name="zisp-wg"]
    } on-error={}

    # Generate private key locally and derive public key
    :local tmpPriv ""
    :local tmpPub ""
    :do {
        /tool fetch url="https://api.ipify.org" mode=http keep-result=no
        # RouterOS doesn't have native wg key gen in older versions; try to use built-in if present
    } on-error={}

    # Create WireGuard interface and let RouterOS generate a key if supported
    :do {
        /interface wireguard add name="zisp-wg" listen-port=0 disabled=no
        :put "WireGuard interface created: zisp-wg"
    } on-error={
        :put "Warning: Could not create WireGuard interface on this RouterOS version"
    }

    # Try to read generated private/public key (RouterOS v7 stores private-key property)
    :do {
        :set tmpPriv [/interface wireguard get [find name="zisp-wg"] private-key]
    } on-error={:set tmpPriv ""}

    # If private-key isn't available (older RouterOS), attempt to generate an ephemeral keypair using /system script (best effort)
    :if ([:len $tmpPriv] = 0) do={
        :put "RouterOS did not expose private-key property; attempting fallback key generation (may not work on older RouterOS)"
        :do {
            # Fallback: attempt to use /system script to call openssl if available (very rare) - this is non-guaranteed
            # Leave tmpPub empty if not possible; cloud can still assign an IP and operator can manually configure later.
            :put "Fallback key generation skipped"
        } on-error={}
    }

    # If we have a private key read, derive public key and post it
    :if ([:len $tmpPriv] > 0) do={
        # Derive public key using built-in command if available
        :do {
            :set tmpPub [/interface wireguard get [find name="zisp-wg"] public-key]
        } on-error={:set tmpPub ""}
    }

    # Assign a tentative tunnel IP from the suggested subnet if provided
    :local requestedIp ""
    :if ([:len "{{wg_subnet}}"] > 0) do={
        # Expect subnet like 10.254.0.0/16 -> assign a /32 by using router ID low bits as host if possible
        # Simpler: leave empty and let cloud assign a specific /32; we'll still phone-home and include local IPs
        :set requestedIp ""
    }

    # Add server peer (server public key and endpoint)
    :if ([:len "{{wg_server_pubkey}}"] > 0) do={
        :do {
            /interface wireguard peers add interface="zisp-wg" public-key="{{wg_server_pubkey}}" endpoint-address="{{wg_server_endpoint}}" endpoint-port="{{wg_port}}" allowed-address="{{wg_subnet}}" persistent-keepalive=25
            :put "Added peer to server {{wg_server_endpoint}}:{{wg_port}}"
        } on-error={
            :put "Warning: Failed to add server peer; please verify RouterOS WireGuard support and syntax"
        }
    } else={
        :put "Server public key not provided; skipping peer addition"
    }

    # Gather local tunnel IP (if any) and network interfaces to include in phone-home
    :local localWgIp ""
    :do {
        :local ids [/ip address find]
        :foreach id in=$ids do={
            :local ipAddr [/ip address get $id address]
            :if ([:find $ipAddr "::"] = -1) do={
                :local ipOnly [:pick $ipAddr 0 [:find $ipAddr "/"]]
                :if ([:pick $ipOnly 0 3] != "127" && [:len $localWgIp] = 0) do={
                    :set localWgIp $ipOnly
                }
            }
        }
    } on-error={}

    # Phone-home with WG public key and local tunnel IP (if available)
    :if ([:len "{{sync_url}}"] > 0) do={
        :local syncUrl "{{sync_url}}"
        :local postData ""
        :if ([:len $tmpPub] > 0) do={
            :set postData ($postData . "wg_public_key=" . $tmpPub)
        }
        :if ([:len $localWgIp] > 0) do={
            :if ([:len $postData] > 0) do={ :set postData ($postData . "&") } on-error={}
            :set postData ($postData . "wg_address=" . $localWgIp)
        }
        :if ([:len $postData] = 0) do={
            # Fallback to regular ip_address phone-home
            :local ipIds [/ip address find]
            :local routerIp ""
            :foreach id in=$ipIds do={
                :local ipAddr [/ip address get $id address]
                :local ipOnly [:pick $ipAddr 0 [:find $ipAddr "/"]]
                :if ([:pick $ipOnly 0 3] != "127" && [:len $routerIp] = 0) do={ :set routerIp $ipOnly }
            }
            :if ([:len $routerIp] > 0) do={ :set postData ("ip_address=" . $routerIp) }
        }

        :do {
            /tool fetch url=$syncUrl http-method=post http-data=$postData
            :put "WireGuard phone-home successful"
        } on-error={
            :put "WireGuard phone-home failed (non-critical)"
        }
    } else={
        :put "No sync URL configured for WireGuard phone-home"
    }
} else={
    :put "WireGuard server info missing; skipping automated WireGuard setup"
}

:put "==================== CONTINUING STANDARD ONBOARDING ===================="

# Phone-home notification (existing logic preserved)
:if ([:len "{{sync_url}}"] > 0) do={
    :local syncUrl "{{sync_url}}"
    :put "Sending initial phone-home notification..."
    :local routerIp ""
    :do {
        :local ipIds [/ip address find]
        :foreach id in=$ipIds do={
            :local ipAddr [/ip address get $id address]
            :local ipOnly [:pick $ipAddr 0 [:find $ipAddr "/"]]
            :if ([:pick $ipOnly 0 3] != "127" && [:len $routerIp] = 0) do={
                :set routerIp $ipOnly
            }
        }
    } on-error={}
    :delay 2s
    :do {
        :local postData ""
        :if ([:len $routerIp] > 0) do={
            :set postData "ip_address=$routerIp"
        }
        /tool fetch url=$syncUrl http-method=post http-data=$postData
        :put "Phone-home successful"
        :if ([:len $routerIp] > 0) do={
            :put "Router IP: $routerIp"
        }
    } on-error={
        :put "Phone-home failed (non-critical)"
        :if ([:len $routerIp] > 0) do={
            :put "Router IP: $routerIp (enter manually)"
        }
    }
    
    # Remove existing phone-home scheduler and script if they exist
    :do {
        /system scheduler remove [find name="zisp-phone-home"]
    } on-error={}
    :do {
        /system script remove [find name="zisp-phone-home"]
    } on-error={}
    
    # Create a stored script for periodic phone-home
    # The script will get the router's IP and send it to the sync URL
    :do {
        :local scriptSource ":local routerIp \"\"; :do { :local ipIds [/ip address find]; :foreach id in=\$ipIds do={ :local ipAddr [/ip address get \$id address]; :local ipOnly [:pick \$ipAddr 0 [:find \$ipAddr \"/\"]]; :if ([:pick \$ipOnly 0 3] != \"127\" && [:len \$routerIp] = 0) do={ :set routerIp \$ipOnly; }; }; } on-error={}; :if ([:len \$routerIp] > 0) do={ :do { :local postData (\"ip_address=\" . \$routerIp); /tool fetch url=\"$syncUrl\" http-method=post http-data=\$postData; } on-error={}; };"
        /system script add name="zisp-phone-home" source=$scriptSource
        :put "Phone-home script created"
    } on-error={
        :put "Warning: Failed to create phone-home script"
    }
    
    # Create scheduler to run the script every 3 minutes
    :do {
        /system scheduler add name="zisp-phone-home" start-time=startup interval=3m on-event="/system script run zisp-phone-home" comment="ZiSP periodic phone-home"
        :put "Periodic phone-home scheduler configured (every 3 minutes)"
    } on-error={
        :put "Warning: Failed to create phone-home scheduler"
    }
} else={
    :put "No sync URL configured"
}

:put "==================== ONBOARDING COMPLETE ===================="
:put "Router connected to ZiSP system"
:put "API User: $username"
:put "API Port: $apiPort"
:put "API Service: Enabled (accessible from any IP)"
:put "=============================================================="
:put "IMPORTANT: Copy one of the IP addresses shown above"
:put "and paste it in the system to complete onboarding."
:put "=============================================================="
